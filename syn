#!/bin/bash

# GLOBAL HELPER FUNCTIONS
err() {
    echo "$@" 1>&2
    exit 1
}

usage() {
    : # TODO
}

get_syn_loc_base() {(
    # Recursive helper function to print syn_loc_base to stdout. It prints
    # nothing if syn config file wasn't found. Used by get_syn_loc_base, which
    # instead errors and exits if syn config file wasn't found.
    local wd="$(pwd)"
    if [ -r .syn ]; then
        echo -n "$wd"
    elif [ "$wd" != "/" ]; then
        cd ..
        get_syn_loc_base
    fi
)}

load_syn_dir() {
    # This loads variables related to the current syn directory:
    # syn_svr           - The remote server (unset if not remote)
    # syn_svr_base      - The path to the base of remote syn dir
    # syn_loc_base      - The path of local syn dir (e.g., /path/to/base)
    # syn_path          - Path from syn dir's base (e.g., /path/in/syn_dir)
    unset syn_svr syn_svr_base syn_loc_base syn_path
    syn_loc_base="$(get_syn_loc_base)"
    if [ "$syn_loc_base" = "" ] || [ ! -r "$syn_loc_base" ]; then
        err "Unable to find syn dir config file"
    fi
    . "${syn_loc_base}/.syn" # sets syn_svr and syn_svr_base
    local wd="$(pwd)"
    syn_path="${wd##$local_base}"
}

save_syn_dir() {
    # Saves the loaded syn directory. This function assumes syn_loc_base,
    # syn_svr, and syn_svr_base are set and valid.
    syn_config_file="${syn_loc_base}/.syn"
    echo "syn_svr=\"${syn_svr}\"" > "$syn_config_file"
    echo "syn_svr_base=\"${syn_svr_base}\"" >> "$syn_config_file"
}

get_full_remote_path() {
    local svr
    if [ -z ${syn_svr+x} ]; then
        # syn_svr unset
        svr=
    else
        # syn_svr set
        svr="${syn_svr}:"
    fi
    echo -n "$svr$syn_path"
}

get_full_local_path() {
    echo -n "$syn_loc_base$syn_path"
}

# FUNCTION COMMAND DECLARATION
init() {
    init_usage() { err 'Usage: syn init [server:]path'; }
    if [ $# -ne 1 ]; then init_usage fi
    syn_loc_base="$(pwd)"
    set "$1"
}

uninit() {
    load_syn_dir
    echo rm -f "${syn_loc_base}/.syn"
}

set() {
    init_set() { err 'Usage: syn set [server:]path'; }
    if [ $# -ne 1 ]; then init_set fi
    load_syn_dir

    # Parse arg
    local arg="$1"
    syn_svr="${arg%:*}"
    syn_svr_base="${arg##*:}"
    # This parsing method may break. It's intended to split server:/syn/dir
    # into server and /syn/dir but also supports user@server:/syn/dir. Also,
    # the parsing rules splits a:b:c:d as a:b:c and d, splitting by the last
    # colon.

    # Saves to .syn
    save_syn_dir
}

push() {
    local OPTIND opt
    # TODO
}

pull() {
    local OPTIND opt
    # TODO
}

help() {
    : # TODO
}

test() {
    load_syn_dir
    save_syn_dir
}

# Handle no args
if [ $# -eq 0 ]; then
    cmd='help'
else
    cmd="$1"
fi # Post: Args were passed

# Forward command
shift
case "$cmd" in
    init)   init "$@" ;;
    uninit) uninit "$@" ;;
    set)    set "$@" ;;
    push)   push "$@" ;;
    pull)   pull "$@" ;;
    help)   help "$@" ;;
    test)   test "$@" ;;
    *)      err "Error: Invalid command: $cmd"
esac
